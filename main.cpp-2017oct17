#include <iostream>
#include <ctime>
#include <unistd.h>
#include <sys/time.h>
#include <iomanip>
#include <pangolin/pangolin.h>
#include <pangolin/scene/axis.h>
#include <pangolin/scene/scenehandler.h>
#include <fstream>

int main( int /*argc*/, char** /*argv*/ )
{  
    pangolin::CreateWindowAndBind("2 CURVAS",640,480);
    glEnable(GL_DEPTH_TEST);
    int readAndDraw=1;

    // Define Projection and initial ModelView matrix
    pangolin::OpenGlRenderState s_cam(
        pangolin::ProjectionMatrix(640,480,420,420,320,240,0.2,100),
        //pangolin::ModelViewLookAt(-2,2,-2, 0,0,0, pangolin::AxisY)
        pangolin::ModelViewLookAt(-5,1.25,-5, 0,0,0, pangolin::AxisY)
    );

    // Create Interactive View in window
    pangolin::Handler3D handler(s_cam);
    pangolin::Renderable tree;
    tree.Add( std::make_shared<pangolin::Axis>() ); 
    pangolin::View& d_cam = pangolin::CreateDisplay()
            .SetBounds(0.0, 1.0, 0.0, 1.0, -640.0f/480.0f)
            .SetHandler(&handler);
     glColor3f(0.75f, 0.75f, 0.75f);
     int cont=0;
     float x,y,z=0;
     timeval a; //Para leer el tiempo del reloj de la maquina
     
     double myMilliseconds;
     gettimeofday(&a, 0);
     //Format decimal point for timestamp precision (SECONDS AND MILLISECONDS)
     std::cout << std::setprecision(6) << std::fixed;
     std::ofstream out( "salidaCurva1.txt" );
     out << std::setprecision(6) << std::fixed;
     // FOR READING FILE AND DRAW CURVE
     std::ifstream infile("misalida.txt");
     std::string line;
     infile >> std::setprecision(6) >> std::fixed;
     double timestamp,rx,ry,rz,q1,q2,q3,q4;
     
     double arx[3000]= {0.0};
     double ary[3000]= {0.0};
     double arz[3000]= {0.0};
     int contLin=0;
     if( !out )
     {
       std::cout << "Couldn't open file."  << std::endl;
       return 1;
     }

    while( !pangolin::ShouldQuit() )
    {
        cont ++;
        // Clear screen and activate view to render into
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        d_cam.Activate(s_cam);

        if (readAndDraw == 1) {
            //while (infile >> timestamp >> rx >> ry >> rz >> q1 >> q2 >> q3 >> q4 )
            if (infile >> timestamp >> rx >> ry >> rz >> q1 >> q2 >> q3 >> q4 )
                {
                arx[contLin]=rx;
                ary[contLin]=ry;
                arz[contLin]=rz;
                
                // if (line == "Path") { continue; }

                // std::istringstream iss(line);
                // int a, b;

                // if (!(iss >> a >> b) || iss.get() != EOF) { /* error! die? */ }

                std::cout << "You said, " << timestamp << " " << arx[contLin] << " " << ary[contLin] << " " << arz[contLin] << " " << q1 << " " << q2 << " " << q3 << " " << q4 << "\n";
                glBegin(GL_POINTS);
                    for (int h=0; h<= contLin; h++){
                       
                        glColor3f(0,1,1);//cyan
                        
                        glVertex3f(arx[h],ary[h],arz[h]); // LINEA QUE DIBUJA UNA CURVA 
                    
                    }
                glEnd();    
                contLin++;
            } else if (contLin > 0 ) {// After reading all coordinates from file. Only have to paint the content of the arrays.
               
                glBegin(GL_POINTS);
                    for (int h=0; h < contLin; h++){// Bucle for, important the < simbol instead of <=
                       
                        glColor3f(0,1,0);//GREEN, when the curve is finished
                        
                        glVertex3f(arx[h],ary[h],arz[h]); // LINEA QUE DIBUJA UNA CURVA 
                    
                    }
                glEnd(); 
            }
        } else { // Draw and Write


        
            // Render OpenGL Cube
            glColor3f(.3,.3,.3);
            /*glBegin(GL_QUADS);
            glVertex3f( 0,-0.001, 0);
            glVertex3f( 0,-0.001,10);
            glVertex3f(10,-0.001,10);
            glVertex3f(10,-0.001, 0);
            glEnd();
            */
            

            // DRAW 2 SINUSOIDAL CURVES IN 3D
            glBegin(GL_POINTS);
            //for(int j=0;j<=2000;j++) {
            for(int j=0;j<=cont;j++) {
                
                //glColor3f(.6,.2,.2);
                //glColor3f(0,1,0);//GREEN           
                glColor3f(1,0,0);//RED           
                //glVertex3f(cos(j*0.02),cos(j*0.01),sin(j*0.05));
                //x=cos(j*0.001)+1;
                x=cos(j*0.013)+1;
                //y=cos(j*0.01)+1;
                y=cos(j*0.006)+1;
                //z=sin(j*0.05)+1;
                z=sin(j*0.007)+1;
                //glVertex3f(x,y,z);
                glVertex3f(x,y+x,z+y+x); // LINEA QUE DIBUJA UNA CURVA 

                //glColor3f(.2,.2,.5);
                glColor3f(1,1,0);//YELLOW
                glVertex3f(x+3,y+1+x,z+3+x+y); // LINE THAT DRAWS A CURVE USGIN COORDINATES FROM THE FIRST CURVE
                // GET TIME (SECONDS AND MILISECONDS)
                gettimeofday(&a, 0);
                myMilliseconds = double( double(a.tv_sec)+  double( double(a.tv_usec)/1000000.0)); 
                //printf("misalida %.2f",double(a.tv_usec)/double(1000000.0));
                //std::cout << "misalida %.2f" <<double(a.tv_sec)+ double(a.tv_usec)/double(1000000.0) << std::endl;
                std::cout << "timeStamp = " << myMilliseconds << "X="<<x<<"Y="<<y<<"Z="<<z<<std::endl;
                out << "timeStamp = " << myMilliseconds << "X="<<x<<"Y="<<y<<"Z="<<z<<"\n"<<std::endl;
                // END GET TIME MILISECONDS

                //glVertex3f(cos(j*0.002)+3,cos(j*0.01)+3,sin(j*0.05)+3);
            }
            glEnd();

        }
        //pangolin::glDrawColouredCube();
        
        // DRAW A  GRID
        glBegin(GL_LINES);
        for(int i=0;i<=10;i++) {
            if (i==0) { glColor3f(.6,.3,.3); } else { glColor3f(.25,.25,.25); };
            glVertex3f(i,0,0);
            glVertex3f(i,0,10);
            if (i==0) { glColor3f(.3,.3,.6); } else { glColor3f(.25,.25,.25); };
            glVertex3f(0,0,i);
            glVertex3f(10,0,i);
           
        };
        glEnd();
        // END DRAW GRID

        tree.Render();

        

        // Swap frames and Process Events
        pangolin::FinishFrame();

        
    }
    out.close();
    return 0;
}
