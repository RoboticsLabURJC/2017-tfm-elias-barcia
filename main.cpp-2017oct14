#include <iostream>
#include <ctime>
#include <unistd.h>
#include <sys/time.h>
#include <iomanip>
#include <pangolin/pangolin.h>
#include <pangolin/scene/axis.h>
#include <pangolin/scene/scenehandler.h>
#include <fstream>

int main( int /*argc*/, char** /*argv*/ )
{  
    pangolin::CreateWindowAndBind("2 CURVAS",640,480);
    glEnable(GL_DEPTH_TEST);

    // Define Projection and initial ModelView matrix
    pangolin::OpenGlRenderState s_cam(
        pangolin::ProjectionMatrix(640,480,420,420,320,240,0.2,100),
        //pangolin::ModelViewLookAt(-2,2,-2, 0,0,0, pangolin::AxisY)
        pangolin::ModelViewLookAt(-5,1.25,-5, 0,0,0, pangolin::AxisY)
    );

    // Create Interactive View in window
    pangolin::Handler3D handler(s_cam);
    pangolin::Renderable tree;
    tree.Add( std::make_shared<pangolin::Axis>() );
    pangolin::View& d_cam = pangolin::CreateDisplay()
            .SetBounds(0.0, 1.0, 0.0, 1.0, -640.0f/480.0f)
            .SetHandler(&handler);
     glColor3f(0.75f, 0.75f, 0.75f);
     int cont=0;
     float x,y,z=0;
     timeval a; //Para leer el tiempo del reloj de la maquina
     
     double myMilliseconds;
     gettimeofday(&a, 0);
     //Format decimal point for timestamp precision (SECONDS AND MILLISECONDS)
     std::cout << std::setprecision(6) << std::fixed;
     std::ofstream out( "salidaCurva1.txt" );
     out << std::setprecision(6) << std::fixed;
     if( !out )
     {
       std::cout << "Couldn't open file."  << std::endl;
       return 1;
     }

    while( !pangolin::ShouldQuit() )
    {
        cont ++;
        // Clear screen and activate view to render into
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        d_cam.Activate(s_cam);

        // Render OpenGL Cube
        glColor3f(.3,.3,.3);
        /*glBegin(GL_QUADS);
        glVertex3f( 0,-0.001, 0);
        glVertex3f( 0,-0.001,10);
        glVertex3f(10,-0.001,10);
        glVertex3f(10,-0.001, 0);
        glEnd();
        */
        // DRAW A  GRID
        glBegin(GL_LINES);
        for(int i=0;i<=10;i++) {
            if (i==0) { glColor3f(.6,.3,.3); } else { glColor3f(.25,.25,.25); };
            glVertex3f(i,0,0);
            glVertex3f(i,0,10);
            if (i==0) { glColor3f(.3,.3,.6); } else { glColor3f(.25,.25,.25); };
            glVertex3f(0,0,i);
            glVertex3f(10,0,i);
           
        };
        glEnd();
        // END DRAW GRID

        // DRAW 2 SINUSOIDAL CURVES IN 3D
        glBegin(GL_POINTS);
        //for(int j=0;j<=2000;j++) {
        for(int j=0;j<=cont;j++) {
            
            //glColor3f(.6,.2,.2);
            //glColor3f(0,1,0);//GREEN           
            glColor3f(1,0,0);//RED           
            //glVertex3f(cos(j*0.02),cos(j*0.01),sin(j*0.05));
            //x=cos(j*0.001)+1;
            x=cos(j*0.013)+1;
            //y=cos(j*0.01)+1;
            y=cos(j*0.006)+1;
            //z=sin(j*0.05)+1;
            z=sin(j*0.007)+1;
            //glVertex3f(x,y,z);
            glVertex3f(x,y+x,z+y+x); // LINEA QUE DIBUJA UNA CURVA 

            //glColor3f(.2,.2,.5);
            glColor3f(1,1,0);//YELLOW
            glVertex3f(x+3,y+1+x,z+3+x+y); // LINE THAT DRAWS A CURVE USGIN COORDINATES FROM THE FIRST CURVE
            
            // GET TIME (SECONDS AND MILISECONDS)
            gettimeofday(&a, 0);
            myMilliseconds = double( double(a.tv_sec)+  double( double(a.tv_usec)/1000000.0)); 
            //printf("misalida %.2f",double(a.tv_usec)/double(1000000.0));
            //std::cout << "misalida %.2f" <<double(a.tv_sec)+ double(a.tv_usec)/double(1000000.0) << std::endl;
            std::cout << "timeStamp = " << myMilliseconds << "X="<<x<<"Y="<<y<<"Z="<<z<<std::endl;
            out << "timeStamp = " << myMilliseconds << "X="<<x<<"Y="<<y<<"Z="<<z<<"\n"<<std::endl;
            // END GET TIME MILISECONDS

            //glVertex3f(cos(j*0.002)+3,cos(j*0.01)+3,sin(j*0.05)+3);
        }
        glEnd();

        //pangolin::glDrawColouredCube();
        tree.Render();

        

        // Swap frames and Process Events
        pangolin::FinishFrame();
        
    }
    out.close();
    return 0;
}
